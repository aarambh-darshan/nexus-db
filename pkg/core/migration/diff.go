// Package migration provides database migration functionality.
package migration

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"time"

	"github.com/nexus-db/nexus/pkg/core/schema"
	"github.com/nexus-db/nexus/pkg/dialects"
)

// ChangeType represents the type of schema change detected.
type ChangeType int

const (
	ChangeCreateTable ChangeType = iota
	ChangeDropTable
	ChangeAddColumn
	ChangeDropColumn
	ChangeModifyColumn
	ChangeAddIndex
	ChangeDropIndex
)

// String returns a human-readable name for the change type.
func (c ChangeType) String() string {
	switch c {
	case ChangeCreateTable:
		return "CREATE TABLE"
	case ChangeDropTable:
		return "DROP TABLE"
	case ChangeAddColumn:
		return "ADD COLUMN"
	case ChangeDropColumn:
		return "DROP COLUMN"
	case ChangeModifyColumn:
		return "MODIFY COLUMN"
	case ChangeAddIndex:
		return "ADD INDEX"
	case ChangeDropIndex:
		return "DROP INDEX"
	default:
		return "UNKNOWN"
	}
}

// SchemaChange represents a single detected difference between schema and database.
type SchemaChange struct {
	Type       ChangeType
	TableName  string
	ColumnName string        // For column-level changes
	IndexName  string        // For index-level changes
	Field      *schema.Field // For add/modify column
	Index      *schema.Index // For add index
	Model      *schema.Model // For create table
}

// DiffResult contains all detected changes between schema and database.
type DiffResult struct {
	Changes []SchemaChange
}

// HasChanges returns true if there are any schema differences.
func (d *DiffResult) HasChanges() bool {
	return len(d.Changes) > 0
}

// Diff compares a target schema with the current database snapshot and returns detected changes.
// The changes, when applied, will make the database match the schema.
func Diff(targetSchema *schema.Schema, currentDB *DatabaseSnapshot) *DiffResult {
	result := &DiffResult{}

	// Build a set of schema table names for quick lookup
	schemaTableNames := make(map[string]bool)
	for _, model := range targetSchema.GetModels() {
		schemaTableNames[model.Name] = true
	}

	// Build a set of DB table names
	dbTableNames := make(map[string]bool)
	for tableName := range currentDB.Tables {
		dbTableNames[tableName] = true
	}

	// 1. Detect tables to CREATE (in schema, not in DB)
	for _, model := range targetSchema.GetModels() {
		if _, exists := currentDB.Tables[model.Name]; !exists {
			result.Changes = append(result.Changes, SchemaChange{
				Type:      ChangeCreateTable,
				TableName: model.Name,
				Model:     model,
			})
		}
	}

	// 2. Detect tables to DROP (in DB, not in schema)
	for tableName := range currentDB.Tables {
		// Skip internal migration table
		if tableName == "_nexus_migrations" {
			continue
		}
		if !schemaTableNames[tableName] {
			result.Changes = append(result.Changes, SchemaChange{
				Type:      ChangeDropTable,
				TableName: tableName,
			})
		}
	}

	// 3. For tables that exist in both, check columns and indexes
	for _, model := range targetSchema.GetModels() {
		tableInfo, exists := currentDB.Tables[model.Name]
		if !exists {
			continue // Already handled as CREATE TABLE
		}

		// Build sets for comparison
		schemaColumns := make(map[string]*schema.Field)
		for _, field := range model.GetFields() {
			schemaColumns[field.Name] = field
		}

		dbColumns := make(map[string]*ColumnInfo)
		for colName, colInfo := range tableInfo.Columns {
			dbColumns[colName] = colInfo
		}

		// Detect columns to ADD (in schema, not in DB)
		for _, field := range model.GetFields() {
			if _, exists := dbColumns[field.Name]; !exists {
				result.Changes = append(result.Changes, SchemaChange{
					Type:       ChangeAddColumn,
					TableName:  model.Name,
					ColumnName: field.Name,
					Field:      field,
				})
			}
		}

		// Detect columns to DROP (in DB, not in schema)
		for colName := range dbColumns {
			if _, exists := schemaColumns[colName]; !exists {
				result.Changes = append(result.Changes, SchemaChange{
					Type:       ChangeDropColumn,
					TableName:  model.Name,
					ColumnName: colName,
				})
			}
		}

		// Detect index changes
		schemaIndexes := make(map[string]*schema.Index)
		for _, idx := range model.Indexes {
			schemaIndexes[idx.Name] = idx
		}

		dbIndexes := make(map[string]*IndexInfo)
		for idxName, idxInfo := range tableInfo.Indexes {
			dbIndexes[idxName] = idxInfo
		}

		// Indexes to ADD
		for _, idx := range model.Indexes {
			if _, exists := dbIndexes[idx.Name]; !exists {
				result.Changes = append(result.Changes, SchemaChange{
					Type:      ChangeAddIndex,
					TableName: model.Name,
					IndexName: idx.Name,
					Index:     idx,
				})
			}
		}

		// Indexes to DROP (only non-autogenerated ones we track)
		for idxName := range dbIndexes {
			// Skip auto-generated indexes (sqlite_autoindex_*, etc.)
			if strings.HasPrefix(idxName, "sqlite_autoindex_") {
				continue
			}
			if _, exists := schemaIndexes[idxName]; !exists {
				result.Changes = append(result.Changes, SchemaChange{
					Type:      ChangeDropIndex,
					TableName: model.Name,
					IndexName: idxName,
				})
			}
		}
	}

	return result
}

// GenerateMigrationFromDiff creates a migration from the detected changes.
func GenerateMigrationFromDiff(dialect dialects.Dialect, changes []SchemaChange, name string) (*Migration, error) {
	if len(changes) == 0 {
		return nil, fmt.Errorf("no changes detected")
	}

	var upStatements []string
	var downStatements []string

	for _, change := range changes {
		switch change.Type {
		case ChangeCreateTable:
			upStatements = append(upStatements, dialect.CreateTableSQL(change.Model))
			downStatements = append(downStatements, dialect.DropTableSQL(change.TableName))

			// Also create indexes for the new table
			for _, idx := range change.Model.Indexes {
				if len(idx.Fields) > 1 || !idx.Unique {
					upStatements = append(upStatements, dialect.CreateIndexSQL(change.TableName, idx))
					downStatements = append(downStatements, dialect.DropIndexSQL(change.TableName, idx.Name))
				}
			}

		case ChangeDropTable:
			upStatements = append(upStatements, dialect.DropTableSQL(change.TableName))
			// Note: For rollback, we would need the full table definition
			// This is a limitation - we can't perfectly reverse a DROP TABLE
			downStatements = append(downStatements, fmt.Sprintf("-- Cannot auto-generate: CREATE TABLE %s (manual intervention required)", change.TableName))

		case ChangeAddColumn:
			upStatements = append(upStatements, dialect.AddColumnSQL(change.TableName, change.Field))
			downStatements = append(downStatements, dialect.DropColumnSQL(change.TableName, change.ColumnName))

		case ChangeDropColumn:
			upStatements = append(upStatements, dialect.DropColumnSQL(change.TableName, change.ColumnName))
			// Note: For rollback, we would need the column definition
			downStatements = append(downStatements, fmt.Sprintf("-- Cannot auto-generate: ADD COLUMN %s.%s (manual intervention required)", change.TableName, change.ColumnName))

		case ChangeAddIndex:
			upStatements = append(upStatements, dialect.CreateIndexSQL(change.TableName, change.Index))
			downStatements = append(downStatements, dialect.DropIndexSQL(change.TableName, change.IndexName))

		case ChangeDropIndex:
			upStatements = append(upStatements, dialect.DropIndexSQL(change.TableName, change.IndexName))
			// Note: For rollback, we would need the index definition
			downStatements = append(downStatements, fmt.Sprintf("-- Cannot auto-generate: CREATE INDEX %s (manual intervention required)", change.IndexName))
		}
	}

	now := time.Now()
	id := now.Format("20060102_150405")

	upSQL := strings.Join(upStatements, ";\n\n") + ";"
	downSQL := strings.Join(downStatements, ";\n\n") + ";"

	hash := sha256.Sum256([]byte(upSQL))
	checksum := hex.EncodeToString(hash[:])

	return &Migration{
		ID:       id,
		Name:     name,
		UpSQL:    upSQL,
		DownSQL:  downSQL,
		Checksum: checksum,
	}, nil
}

// DescribeChanges returns a human-readable description of the changes.
func DescribeChanges(changes []SchemaChange) []string {
	var descriptions []string
	for _, change := range changes {
		var desc string
		switch change.Type {
		case ChangeCreateTable:
			desc = fmt.Sprintf("+ CREATE TABLE %s", change.TableName)
		case ChangeDropTable:
			desc = fmt.Sprintf("- DROP TABLE %s", change.TableName)
		case ChangeAddColumn:
			desc = fmt.Sprintf("+ ADD COLUMN %s.%s", change.TableName, change.ColumnName)
		case ChangeDropColumn:
			desc = fmt.Sprintf("- DROP COLUMN %s.%s", change.TableName, change.ColumnName)
		case ChangeModifyColumn:
			desc = fmt.Sprintf("~ MODIFY COLUMN %s.%s", change.TableName, change.ColumnName)
		case ChangeAddIndex:
			desc = fmt.Sprintf("+ ADD INDEX %s.%s", change.TableName, change.IndexName)
		case ChangeDropIndex:
			desc = fmt.Sprintf("- DROP INDEX %s.%s", change.TableName, change.IndexName)
		}
		descriptions = append(descriptions, desc)
	}
	return descriptions
}
